{% extends "dashboard/admin/base.html" %}
{% load static %}

{% block page_title %}{{ page_title|default:"Create Questionnaire" }}{% endblock %}

{% block admin_content %}
<div class="container mx-auto px-4 py-8">
    <!-- Header -->
    <div class="flex justify-between items-center mb-6">
        <h1 class="h2 mb-0">{{ page_title|default:"Questionnaire Builder" }}</h1>
        <div class="flex space-x-4">
            <button onclick="saveQuestionnaire()" class="btn btn-primary">
                <i class="fas fa-save mr-2"></i> {% if questionnaire %}Update{% else %}Save{% endif %} Questionnaire
            </button>
        </div>
    </div>

    <!-- Questionnaire Info -->
    <div class="card mb-8">
        <div class="card-body">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                    <label class="form-label fw-semibold">Questionnaire Title *</label>
                    <input type="text" id="questionnaireTitle" class="form-input" 
                           placeholder="e.g., Medical Screening Form"
                           value="{% if questionnaire %}{{ questionnaire.title }}{% endif %}">
                </div>
                <div>
                    <label class="form-label fw-semibold">Description</label>
                    <textarea id="questionnaireDescription" class="form-textarea" rows="3" 
                              placeholder="Brief description of the questionnaire">{% if questionnaire %}{{ questionnaire.description }}{% endif %}</textarea>
                </div>
            </div>
        </div>
    </div>

    <!-- Questions Section -->
    <div class="card">
        <div class="card-body" data-questions-data="{% if questions_data %}{{ questions_data|safe }}{% endif %}">
            <div class="flex justify-between items-center mb-6">
                <h2 class="h4 mb-0">Questions</h2>
                <button onclick="addQuestion()" class="btn btn-secondary">
                    <i class="fas fa-plus mr-2"></i> Add Question
                </button>
            </div>

            <div id="questionsContainer" class="space-y-6">
                <!-- Questions will be added here dynamically -->
            </div>

            <div id="emptyState" class="text-center py-12 text-gray-500">
                <i class="fas fa-question-circle text-6xl mb-4"></i>
                <p class="text-lg">No questions added yet</p>
                <p class="text-sm">Click "Add Question" to get started</p>
            </div>
        </div>
    </div>
</div>

<!-- Question Template (hidden) -->
<template id="questionTemplate">
    <div class="question-item border border-gray-700 rounded-lg p-6" data-question-id="">
        <div class="flex justify-between items-start mb-4">
            <div class="flex-1">
                <div class="flex items-center space-x-4 mb-4">
                    <span class="text-gray-400">Question #<span class="question-number">1</span></span>
                    <button onclick="removeQuestion(this)" class="text-red-400 hover:text-red-300">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
                
                <!-- Question Text -->
                <div class="mb-4">
                    <label class="form-label fw-semibold">Question *</label>
                    <textarea class="question-text form-textarea" rows="2" placeholder="Enter your question here"></textarea>
                </div>

                <!-- Question Type -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                    <div>
                        <label class="form-label fw-semibold">Question Type *</label>
                        <select class="question-type form-select" onchange="handleQuestionTypeChange(this)">
                            <option value="">Select question type</option>
                            <option value="yes_no">Yes/No</option>
                            <option value="true_false">True/False</option>
                            <option value="multiple_choice">Multiple Choice</option>
                            <option value="short_answer">Short Answer</option>
                        </select>
                        <div class="yes-no-actions hidden mt-3">
                            <p class="text-sm font-semibold mb-2 text-gray-400">Branching Rules (Optional)</p>
                            <div class="flex space-x-2">
                                <button type="button" onclick="addFollowUp(this, 'yes')" class="btn btn-sm btn-outline-success">
                                    <i class="fas fa-plus mr-1"></i> Add YES follow-up
                                </button>
                                <button type="button" onclick="addFollowUp(this, 'no')" class="btn btn-sm btn-outline-danger">
                                    <i class="fas fa-plus mr-1"></i> Add NO follow-up
                                </button>
                            </div>
                        </div>
                    </div>
                    <div>
                        <label class="flex items-center mt-6">
                            <input type="checkbox" class="question-required mr-2" checked>
                            <span class="text-gray-300">Required</span>
                        </label>
                    </div>
                </div>

                <!-- Multiple Choice Options (hidden by default) -->
                <div class="multiple-choice-options hidden">
                    <div class="flex justify-between items-center mb-4">
                        <label class="form-label fw-semibold">Options</label>
                        <button onclick="addOption(this)" class="btn btn-secondary btn-sm">
                            <i class="fas fa-plus mr-1"></i> Add Option
                        </button>
                    </div>
                    <div class="options-container space-y-3">
                        <!-- Options will be added here -->
                    </div>
                </div>

                <!-- Follow-up Questions Container -->
                <div class="followups-container border-l-2 border-indigo-500 pl-4 mt-4 space-y-4 empty:hidden">
                    <!-- Nested questions added here -->
                </div>
            </div>
        </div>
    </div>
</template>

<!-- Option Template (hidden) -->
<template id="optionTemplate">
    <div class="option-item border rounded p-3 mb-2">
        <div class="d-flex align-items-start gap-3">
            <button type="button" onclick="removeOption(this)" class="btn btn-sm btn-outline-danger mt-1">
                <i class="fas fa-times"></i>
            </button>
            
            <div class="flex-grow-1">
                <div class="row align-items-center">
                    <!-- Text Option -->
                    <div class="col-md-6">
                        <label class="form-label small fw-semibold">Text Option</label>
                        <input type="text" class="option-text form-control form-control-sm" 
                               placeholder="Enter option text" 
                               onchange="handleOptionTextChange(this)">
                    </div>
                    
                    <!-- OR Divider -->
                    <div class="col-auto">
                        <div class="text-muted small fw-bold">OR</div>
                    </div>
                    
                    <!-- Image Option -->
                    <div class="col-md-5">
                        <label class="form-label small fw-semibold">Image Option</label>
                        <div class="d-flex gap-2">
                            <input type="file" class="option-image d-none" accept="image/*" 
                                   onchange="handleImageUpload(this)">
                            <button type="button" onclick="this.previousElementSibling.click()" 
                                    class="btn btn-sm btn-outline-secondary">
                                <i class="fas fa-image me-1"></i> Choose Image
                            </button>
                            <div class="option-image-preview d-none">
                                <img src="" alt="" class="img-thumbnail" style="max-height: 40px; max-width: 60px;">
                            </div>
                        </div>
                        <div class="option-image-name small text-muted mt-1"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</template>

<script>
let questionCounter = 0;
let optionCounter = 0;

function addQuestion() {
    questionCounter++;
    const template = document.getElementById('questionTemplate');
    const clone = template.content.cloneNode(true);
    
    // Set question ID and number
    const questionItem = clone.querySelector('.question-item');
    questionItem.dataset.questionId = 'new_' + questionCounter;
    
    // Add to container
    const container = document.getElementById('questionsContainer');
    container.appendChild(clone);
    
    // Hide empty state
    document.getElementById('emptyState').classList.add('hidden');
    
    // Reorder questions
    updateQuestionNumbers();
}

function addFollowUp(btn, triggerAnswer) {
    questionCounter++;
    const template = document.getElementById('questionTemplate');
    const clone = template.content.cloneNode(true);
    
    // Set question ID and number
    const questionItem = clone.querySelector('.question-item');
    questionItem.dataset.questionId = 'new_' + questionCounter;
    questionItem.dataset.triggerAnswer = triggerAnswer;
    
    // Style as followup
    questionItem.classList.replace('border-gray-700', triggerAnswer === 'yes' ? 'border-green-800' : 'border-red-800');
    questionItem.style.marginTop = '1rem';
    
    // Add label indicator
    const labelSpan = document.createElement('span');
    labelSpan.className = `ml-3 px-2 py-1 rounded text-xs font-bold ${triggerAnswer === 'yes' ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`;
    labelSpan.textContent = `If ${triggerAnswer.toUpperCase()}`;
    clone.querySelector('.flex.items-center.space-x-4').appendChild(labelSpan);
    
    // Find followups container of parent
    const parentContainer = btn.closest('.question-item').querySelector('.followups-container');
    parentContainer.appendChild(clone);
    
    // Reorder questions
    updateQuestionNumbers();
}

function removeQuestion(button) {
    const questionItem = button.closest('.question-item');
    questionItem.remove();
    
    // Show empty state if no top-level questions
    const container = document.getElementById('questionsContainer');
    if (container.children.length === 0) {
        document.getElementById('emptyState').classList.remove('hidden');
    }
    
    // Reorder questions
    updateQuestionNumbers();
}

function updateQuestionNumbers() {
    const buildNumbers = (container, prefix) => {
        let count = 1;
        // Immediate children only
        Array.from(container.children).forEach(item => {
            if (!item.classList.contains('question-item')) return;
            const num = prefix ? `${prefix}.${count}` : `${count}`;
            item.querySelector('.question-number').textContent = num;
            
            // Recurse into followups
            const followupsContainer = item.querySelector('.followups-container');
            if (followupsContainer) {
                // Determine suffix based on trigger answer
                let nextPrefix = num;
                Array.from(followupsContainer.children).forEach(followup => {
                    const trigger = followup.dataset.triggerAnswer;
                    if (trigger === 'yes') followup.querySelector('.question-number').textContent = num + '.1';
                    if (trigger === 'no') followup.querySelector('.question-number').textContent = num + '.2';
                    
                    // Recursive call for deeper nesting
                    const nestedFollowups = followup.querySelector('.followups-container');
                    if (nestedFollowups) buildNumbers(nestedFollowups, followup.querySelector('.question-number').textContent);
                });
            }
            if (!prefix) count++;
        });
    };
    buildNumbers(document.getElementById('questionsContainer'), '');
}

function handleQuestionTypeChange(select) {
    const questionItem = select.closest('.question-item');
    const optionsContainer = questionItem.querySelector('.multiple-choice-options');
    const yesNoActions = questionItem.querySelector('.yes-no-actions');
    
    if (select.value === 'multiple_choice') {
        optionsContainer.classList.remove('hidden');
        if (yesNoActions) yesNoActions.classList.add('hidden');
        // Add default options if none exist
        const container = optionsContainer.querySelector('.options-container');
        if (container.children.length === 0) {
            addOption(optionsContainer.querySelector('.btn'));
            addOption(optionsContainer.querySelector('.btn'));
        }
    } else if (select.value === 'yes_no') {
        optionsContainer.classList.add('hidden');
        if (yesNoActions) yesNoActions.classList.remove('hidden');
    } else {
        optionsContainer.classList.add('hidden');
        if (yesNoActions) yesNoActions.classList.add('hidden');
    }
}

function addOption(button) {
    optionCounter++;
    const template = document.getElementById('optionTemplate');
    const clone = template.content.cloneNode(true);
    
    // Add to options container
    const optionsContainer = button.closest('.multiple-choice-options').querySelector('.options-container');
    optionsContainer.appendChild(clone);
}

function removeOption(button) {
    const optionItem = button.closest('.option-item');
    optionItem.remove();
}

function handleImageUpload(input) {
    const file = input.files[0];
    const optionItem = input.closest('.option-item');
    const nameSpan = optionItem.querySelector('.option-image-name');
    const previewDiv = optionItem.querySelector('.option-image-preview');
    const textInput = optionItem.querySelector('.option-text');
    
    if (file) {
        // Validate file type
        if (!file.type.startsWith('image/')) {
            alert('Please select an image file');
            input.value = '';
            return;
        }
        
        // Validate file size (5MB limit)
        const maxSize = 5 * 1024 * 1024;
        if (file.size > maxSize) {
            alert('Image file must be less than 5MB');
            input.value = '';
            return;
        }
        
        // Show file name
        nameSpan.textContent = file.name;
        
        // Show preview
        const reader = new FileReader();
        reader.onload = function(e) {
            const img = previewDiv.querySelector('img');
            img.src = e.target.result;
            previewDiv.classList.remove('d-none');
        };
        reader.readAsDataURL(file);
        
        // Clear and disable text input
        textInput.value = '';
        textInput.disabled = true;
        textInput.classList.add('bg-light');
    } else {
        // Hide preview and clear name
        nameSpan.textContent = '';
        previewDiv.classList.add('d-none');
        
        // Enable text input
        textInput.disabled = false;
        textInput.classList.remove('bg-light');
    }
}

function handleOptionTextChange(input) {
    const optionItem = input.closest('.option-item');
    const imageInput = optionItem.querySelector('.option-image');
    const previewDiv = optionItem.querySelector('.option-image-preview');
    const nameSpan = optionItem.querySelector('.option-image-name');
    
    // If text is entered, clear image
    if (input.value.trim()) {
        imageInput.value = '';
        previewDiv.classList.add('d-none');
        nameSpan.textContent = '';
    }
}

function saveQuestionnaire() {
    const title = document.getElementById('questionnaireTitle').value.trim();
    const description = document.getElementById('questionnaireDescription').value.trim();
    
    if (!title) {
        alert('Please enter a questionnaire title');
        return;
    }
    
    const questions = [];
    
    // Flatten hierarchy and assign ids/parents
    const flattenQuestions = (container, parentId = null) => {
        const items = container.children;
        Array.from(items).forEach((item) => {
            if (!item.classList.contains('question-item')) return;
            
            const questionText = item.querySelector('.question-text').value.trim();
            const questionType = item.querySelector('.question-type').value;
            const isRequired = item.querySelector('.question-required').checked;
            const itemId = item.dataset.dbId || item.dataset.questionId;
            const triggerAnswer = item.dataset.triggerAnswer || null;
            
            if (!questionText || !questionType) {
                throw new Error('Please complete all question fields');
            }
            
            const question = {
                id: itemId,
                parent_id: parentId,
                trigger_answer: triggerAnswer,
                question_text: questionText,
                type: questionType,
                required: isRequired,
                order: questions.length + 1
            };
            
            // Add options for multiple choice questions
            if (questionType === 'multiple_choice') {
                const options = [];
                const optionItems = item.querySelectorAll('.option-item');
                
                for (const optionItem of optionItems) {
                    const text = optionItem.querySelector('.option-text').value.trim();
                    const imageInput = optionItem.querySelector('.option-image');
                    const imageFile = imageInput && imageInput.files ? imageInput.files[0] : null;
                    
                    if (text || imageFile) {
                        options.push({
                            text: text,
                            image_file: imageFile,
                            order: options.length + 1
                        });
                    }
                }
                
                if (options.length < 2) {
                    throw new Error('Multiple choice questions must have at least 2 options');
                }
                
                question.options = options;
            }
            
            questions.push(question);
            
            // Recurse into children
            const followupsContainer = item.querySelector('.followups-container');
            if (followupsContainer) {
                flattenQuestions(followupsContainer, itemId);
            }
        });
    };
    
    try {
        flattenQuestions(document.getElementById('questionsContainer'));
    } catch(e) {
        alert(e.message);
        return;
    }

    
    if (questions.length === 0) {
        alert('Please add at least one question');
        return;
    }
    
    // Send data to backend
    const csrftoken = getCookie('csrftoken');
    
    console.log('Sending data:', {
        title,
        description,
        questions
    });
    
    // Determine if we're in edit mode
    const isEditMode = {% if questionnaire %}true{% else %}false{% endif %};
    const url = isEditMode ? '/questionnaires/builder/{% if questionnaire %}{{ questionnaire.pk }}{% endif %}/edit/' : '/questionnaires/api/save/';
    
    fetch(url, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrftoken
        },
        body: JSON.stringify({
            title,
            description,
            questions
        })
    })
    .then(response => {
        console.log('Response status:', response.status);
        return response.json();
    })
    .then(data => {
        console.log('Response data:', data);
        if (data.success) {
            alert('Questionnaire ' + (isEditMode ? 'updated' : 'saved') + ' successfully!');
            // Redirect to admin list
            window.location.href = '/dashboard/admin/questionnaires/';
        } else {
            alert('Error: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error ' + (isEditMode ? 'updating' : 'saving') + ' questionnaire. Please try again.');
    });
}

// Helper function to get CSRF token
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

// Initialize
document.addEventListener('DOMContentLoaded', function() {
    // Load existing questions if in edit mode
    const questionsDataElement = document.querySelector('[data-questions-data]');
    const questionsData = questionsDataElement ? JSON.parse(questionsDataElement.getAttribute('data-questions-data') || '[]') : [];
    
    if (questionsData && questionsData.length > 0) {
        // Clear the empty state
        document.getElementById('emptyState').classList.add('hidden');
        
        // Rebuild hierarchy
        const questionMap = {};
        const roots = [];
        
        // Create maps
        questionsData.forEach(q => {
            q.children = [];
            questionMap[q.id] = q;
        });
        
        // Build tree
        questionsData.forEach(q => {
            if (q.parent_id && questionMap[q.parent_id]) {
                questionMap[q.parent_id].children.push(q);
            } else {
                roots.push(q);
            }
        });
        
        // Render tree
        const renderTree = (nodeData, containerNode, isFollowUp = false) => {
            const itemNode = addQuestionNode(nodeData, containerNode, isFollowUp);
            if (nodeData.children && nodeData.children.length > 0) {
                const followupsContainer = itemNode.querySelector('.followups-container');
                nodeData.children.forEach(child => renderTree(child, followupsContainer, true));
            }
        };
        
        const container = document.getElementById('questionsContainer');
        roots.forEach(r => renderTree(r, container, false));
        
        updateQuestionNumbers();
        
    } else {
        // Add initial question for new questionnaires
        addQuestion();
    }
});

function addQuestionNode(existingData, parentContainer, isFollowUp) {
    questionCounter++;
    const template = document.getElementById('questionTemplate');
    const clone = template.content.cloneNode(true);
    
    // Set question ID
    const questionItem = clone.querySelector('.question-item');
    questionItem.dataset.questionId = 'existing_' + questionCounter;
    
    if (existingData) {
        questionItem.dataset.dbId = existingData.id;
        
        clone.querySelector('.question-text').value = existingData.question_text || existingData.text || '';
        clone.querySelector('.question-type').value = existingData.type || '';
        clone.querySelector('.question-required').checked = existingData.required || false;
        
        if (isFollowUp) {
            questionItem.dataset.triggerAnswer = existingData.trigger_answer;
            questionItem.classList.replace('border-gray-700', existingData.trigger_answer === 'yes' ? 'border-green-800' : 'border-red-800');
            questionItem.style.marginTop = '1rem';
            
            const labelSpan = document.createElement('span');
            labelSpan.className = `ml-3 px-2 py-1 rounded text-xs font-bold ${existingData.trigger_answer === 'yes' ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`;
            labelSpan.textContent = `If ${existingData.trigger_answer.toUpperCase()}`;
            clone.querySelector('.flex.items-center.space-x-4').appendChild(labelSpan);
        }
        
        // Handle question type change to show options if needed
        const questionTypeSelect = clone.querySelector('.question-type');
        setTimeout(() => {
            handleQuestionTypeChange(questionTypeSelect);
            if (existingData.type === 'multiple_choice' && existingData.options) {
                const optionsContainer = questionItem.querySelector('.options-container');
                existingData.options.forEach(optionData => {
                    addOptionWithText(questionItem, optionData.text, optionData.order);
                });
            }
        }, 0);
    }
    
    parentContainer.appendChild(clone);
    return parentContainer.lastElementChild;
}

// Deprecated since we use addQuestionNode for rendering, keeping it around just in case
function addQuestion(existingData = null) {
    questionCounter++;
    const template = document.getElementById('questionTemplate');
    const clone = template.content.cloneNode(true);
    
    // Set question ID and number
    const questionItem = clone.querySelector('.question-item');
    questionItem.dataset.questionId = questionCounter;
    clone.querySelector('.question-number').textContent = questionCounter;
    
    // Load existing data if provided
    if (existingData) {
        clone.querySelector('.question-text').value = existingData.question_text || existingData.text || '';
        clone.querySelector('.question-type').value = existingData.type || '';
        clone.querySelector('.question-required').checked = existingData.required || false;
        
        // Handle question type change to show options if needed
        const questionTypeSelect = clone.querySelector('.question-type');
        if (existingData.type === 'multiple_choice' && existingData.options) {
            // Add options after the element is in the DOM
            setTimeout(() => {
                handleQuestionTypeChange(questionTypeSelect);
                const optionsContainer = questionItem.querySelector('.options-container');
                existingData.options.forEach(optionData => {
                    addOptionWithText(questionItem, optionData.text, optionData.order);
                });
            }, 0);
        }
    }
    
    // Add to container
    const container = document.getElementById('questionsContainer');
    container.appendChild(clone);
    
    // Hide empty state
    document.getElementById('emptyState').classList.add('hidden');
    
    updateQuestionNumbers();
}

// Helper function to add option with existing text
function addOptionWithText(questionItem, text, order) {
    optionCounter++;
    const template = document.getElementById('optionTemplate');
    const clone = template.content.cloneNode(true);
    
    // Set the text value
    clone.querySelector('.option-text').value = text || '';
    
    // Add to options container
    const optionsContainer = questionItem.querySelector('.options-container');
    optionsContainer.appendChild(clone);
}
</script>
{% endblock %}
